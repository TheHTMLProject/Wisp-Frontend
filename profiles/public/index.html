<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <link rel="canonical" href="https://lightlink.space/profiles/" />
  <title>messages</title>

  <link
    href="https://fonts.googleapis.com/css2?family=gg+sans:wght@300;400;500;600;700&family=Inter:wght@400;500;600&display=swap"
    rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
  <link rel="manifest" href="manifest.json">

  <script src="js/three.js"></script>
  <script src="js/vanta.js"></script>

  <style>
    :root {
      --bg-tertiary: #202225;
      --bg-secondary: #2f3136;
      --bg-primary: #36393f;
      --bg-secondary-alt: #292b2f;
      --channel-textarea: #40444b;
      --header-primary: #fff;
      --header-secondary: #b9bbbe;
      --text-normal: #dcddde;
      --text-muted: #72767d;
      --interactive-normal: #b9bbbe;
      --interactive-hover: #dcddde;
      --interactive-active: #fff;
      --brand: #5865f2;
      --brand-hover: #4752c4;
      --green: #3ba55c;
      --red: #ed4245;
      --yellow: #fee75c;
      --divider: rgba(255, 255, 255, 0.06);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: 'gg sans', 'Inter', sans-serif;
      background: var(--bg-tertiary);
      color: var(--text-normal);
      overflow: hidden;
    }

    /* Layout */
    .app-container {
      display: flex;
      width: 100%;
      height: 100%;
    }

    /* 1. Server Rail */
    .server-rail {
      width: 72px;
      background: var(--bg-tertiary);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 12px;
      gap: 8px;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .server-icon {
      width: 48px;
      height: 48px;
      background: var(--bg-primary);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 24px;
      color: var(--text-normal);
      transition: all 0.2s;
      position: relative;
    }

    .server-icon:hover {
      background: var(--brand);
      color: #fff;
      border-radius: 16px;
    }

    .server-icon.active {
      border-radius: 16px;
      background: var(--brand);
      color: #fff;
    }

    .server-icon.home {
      background: #36393f;
      color: #fff;
    }

    .server-icon.home:hover,
    .server-icon.home.active {
      background: #5865f2;
    }

    .server-separator {
      width: 32px;
      height: 2px;
      background: var(--divider);
      border-radius: 1px;
    }

    /* 2. Sidebar (Channels/DMs) */
    .sidebar {
      width: 240px;
      background: var(--bg-secondary);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar-header {
      height: 48px;
      padding: 0 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-bottom: 1px solid rgba(0, 0, 0, 0.2);
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);
    }

    .search-btn {
      width: 100%;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      border: none;
      border-radius: 4px;
      padding: 6px;
      text-align: left;
      font-size: 13px;
      cursor: pointer;
    }

    .sidebar-nav {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .nav-item {
      display: flex;
      align-items: center;
      padding: 10px 8px;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-weight: 500;
      margin-bottom: 2px;
    }

    .nav-item:hover {
      background: rgba(255, 255, 255, 0.04);
      color: var(--interactive-hover);
    }

    .nav-item.active {
      background: rgba(255, 255, 255, 0.08);
      /* Selected channel bg */
      color: #fff;
    }

    .nav-item-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      margin-right: 12px;
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: #fff;
    }

    .dm-header {
      text-transform: uppercase;
      font-size: 12px;
      font-weight: 700;
      color: var(--text-muted);
      padding: 18px 8px 8px 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .dm-header:hover {
      color: var(--interactive-hover);
    }

    /* User Area (Bottom of Sidebar) */
    .user-area {
      background: var(--bg-secondary-alt);
      height: 52px;
      padding: 0 8px;
      display: flex;
      align-items: center;
      flex-shrink: 0;
    }

    .user-avatar-wrapper {
      position: relative;
      margin-right: 8px;
      cursor: pointer;
    }

    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--brand);
      /* Default color for self */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .user-info {
      flex: 1;
      overflow: hidden;
      cursor: pointer;
    }

    .user-name {
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .user-discriminator {
      font-size: 12px;
      color: var(--text-muted);
    }

    .user-controls {
      display: flex;
    }

    .control-btn {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-normal);
      font-size: 20px;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--interactive-hover);
    }

    /* 3. Main Content */
    .main-content {
      flex: 1;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      min-width: 0;
      position: relative;
      /* Context for absolute overlay */
    }

    .chat-header {
      height: 48px;
      padding: 0 16px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid rgba(0, 0, 0, 0.2);
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);
    }

    .header-icon {
      font-size: 24px;
      color: var(--text-muted);
      margin-right: 8px;
    }

    .header-title {
      font-weight: 700;
      color: var(--header-primary);
      font-size: 16px;
      margin-right: 8px;
    }

    .header-toolbar {
      margin-left: auto;
      display: flex;
      gap: 16px;
      color: var(--interactive-normal);
      font-size: 24px;
    }

    .toolbar-icon {
      cursor: pointer;
    }

    .toolbar-icon:hover {
      color: var(--interactive-hover);
    }

    /* Messages */
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 0 16px;
      display: flex;
      flex-direction: column;
    }

    .chat-messages::-webkit-scrollbar {
      width: 8px;
      background: #2e3338;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: #202225;
      border-radius: 4px;
    }

    .message-group {
      margin-top: 17px;
      padding: 2px 0;
      display: flex;
    }

    .message-group:hover {
      background: rgba(0, 0, 0, 0.04);
      /* Subtle highlight */
    }

    .message-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-secondary);
      margin-right: 16px;
      margin-top: 2px;
      flex-shrink: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: #fff;
    }

    .message-content {
      flex: 1;
      min-width: 0;
    }

    .message-header {
      display: flex;
      align-items: baseline;
    }

    .message-username {
      font-size: 16px;
      font-weight: 600;
      color: var(--header-primary);
      margin-right: 8px;
      cursor: pointer;
    }

    .message-username:hover {
      text-decoration: underline;
    }

    .message-timestamp {
      font-size: 12px;
      color: var(--text-muted);
    }

    .message-body {
      margin-top: 2px;
      font-size: 16px;
      line-height: 1.375rem;
      color: var(--text-normal);
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    /* Input Area */
    .input-area {
      padding: 0 16px 24px;
      flex-shrink: 0;
    }

    .input-wrapper {
      background: var(--channel-textarea);
      border-radius: 8px;
      padding: 11px;
      /* 44px min height approx */
      display: flex;
      align-items: center;
    }

    .input-wrapper input {
      background: transparent;
      border: none;
      color: var(--text-normal);
      width: 100%;
      font-size: 16px;
      outline: none;
    }

    .input-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-left: 10px;
    }

    .input-btn {
      color: var(--interactive-normal);
      cursor: pointer;
      font-size: 24px;
      display: flex;
    }

    .input-btn:hover {
      color: var(--interactive-hover);
    }

    /* Modals & Overlays */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-box {
      background: var(--bg-primary);
      width: 440px;
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      overflow: hidden;
      animation: scaleIn 0.2s ease;
    }

    @keyframes scaleIn {
      from {
        transform: scale(0.5);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .media-grid {
      display: none;
    }

    /* Call Overlay */
    #callOverlay {
      position: absolute;
      /* Relative to main-content */
      inset: 0;
      background: #000;
      z-index: 101;
      display: flex;
      flex-direction: column;
      display: none;
    }

    #callOverlay.active {
      display: flex;
    }

    .call-grid {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 20px;
    }

    .call-controls {
      height: 80px;
      background: #111;
      display: flex;
      justify-content: center;
      gap: 20px;
      align-items: center;
    }

    .call-btn-circle {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: #2f3136;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
    }

    .call-btn-circle.red {
      background: var(--red);
    }

    .call-btn-circle:hover {
      opacity: 0.8;
    }

    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
    }

    /* Voice Connection Panel */
    .voice-connection-panel {
      background: var(--bg-secondary-alt);
      border-bottom: 1px solid rgba(0, 0, 0, 0.2);
      padding: 8px;
      display: none;
      /* Flex when active */
      flex-direction: column;
    }

    .voice-connection-panel.active {
      display: flex;
    }

    .connection-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--green);
      font-size: 12px;
      font-weight: 700;
      margin-bottom: 4px;
    }

    .connection-channel {
      color: var(--text-normal);
      font-size: 14px;
      font-weight: 600;
    }

    .connection-controls {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
    }

    .mini-control-btn {
      background: transparent;
      border: none;
      color: var(--text-normal);
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
    }

    .mini-control-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }


    /* Refined Call Grid */
    .call-video-container {
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      background: #202225;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
      border: 2px solid transparent;
    }

    .call-video-container.speaking {
      border-color: var(--green);
    }

    .video-name-overlay {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 600;
      z-index: 10;
      pointer-events: none;
    }

    .hidden {
      display: none !important;
    }

    /* PiP Container */
    #pipContainer {
      position: absolute;
      top: 60px;
      /* Below header */
      right: 20px;
      width: 240px;
      height: 160px;
      background: #000;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 102;
      /* Above everything */
      display: none;
      overflow: hidden;
      border: 2px solid var(--bg-secondary);
      cursor: pointer;
    }

    #pipContainer.active {
      display: block;
    }

    #pipContainer video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
  </style>
</head>

<body>
  <div class="app-container" id="app">
    <!-- 1. Server Rail -->
    <div class="server-rail">
      <div class="server-icon home active" id="homeBtn" onclick="backToSafeList()">
        <i class="ri-discord-fill"></i>
      </div>
      <div class="server-separator"></div>
      <!-- Add Server Button (future) -->
      <div class="server-icon" style="color:var(--green); background:var(--bg-primary);" onclick="showNewChatModal()">
        <i class="ri-add-line"></i>
      </div>
    </div>

    <!-- 2. Sidebar -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <button class="search-btn" onclick="showNewChatModal()">Find or start a conversation</button>
      </div>

      <div class="sidebar-nav" id="sidebarNav">
        <!-- DMs and Channels go here -->
        <div class="nav-item">
          <div class="nav-item-avatar"><i class="ri-user-smile-line"></i></div>
          <div>Friends</div>
        </div>
        <div class="dm-header">
          <span>Direct Messages</span>
          <i class="ri-add-line" style="cursor:pointer;" onclick="showNewChatModal()"></i>
        </div>
        <div id="chatList"></div>
      </div>

      <div class="voice-connection-panel" id="voicePanel">
        <div class="connection-info">
          <span><i class="ri-signal-tower-fill"></i> Voice Connected</span>
          <span style="color:var(--text-muted); cursor:pointer;" onclick="endCall()"><i
              class="ri-close-line"></i></span>
        </div>
        <div class="connection-channel" id="voiceChannelName">General / Server</div>
        <div class="connection-controls">
          <button class="mini-control-btn" onclick="toggleMute()"><i class="ri-mic-fill"></i></button>
          <button class="mini-control-btn" onclick="toggleScreenShare()"><i class="ri-computer-line"></i></button>
          <button class="mini-control-btn" onclick="document.getElementById('callOverlay').classList.add('active')"><i
              class="ri-fullscreen-fill"></i></button>
          <button class="mini-control-btn" onclick="endCall()" style="color:var(--red);"><i
              class="ri-phone-end-fill"></i></button>
        </div>
      </div>

      <div class="user-area">
        <div class="user-avatar-wrapper" onclick="showSettings()">
          <div class="user-avatar" id="myAvatarDisplay">?</div>
          <div
            style="position:absolute; bottom:-2px; right:-2px; width:10px; height:10px; border-radius:50%; background:var(--green); border:2px solid var(--bg-secondary-alt);">
          </div>
        </div>
        <div class="user-info" onclick="showSettings()">
          <div class="user-name" id="myUsernameDisplay">Loading...</div>
        </div>
        <div class="user-controls">
          <div class="control-btn" onclick="toggleMute()" id="sidebarMuteBtn"><i class="ri-mic-fill"></i></div>
          <div class="control-btn" onclick="toggleDeafen()"><i class="ri-headphone-fill"></i></div>
          <div class="control-btn" onclick="showSettings()"><i class="ri-settings-5-fill"></i></div>
        </div>
      </div>
    </div>

    <!-- 3. Main Content -->
    <div class="main-content" id="mainView">
      <!-- Empty State -->
      <div class="empty-state" id="emptyState">
        <i class="ri-discord-fill" style="font-size: 64px; margin-bottom: 20px;"></i>
        <h3>Wumpus is waiting...</h3>
        <p>Select a friend to start chatting.</p>
      </div>

      <!-- Chat View -->
      <div class="chat-container hidden" id="chatInterface" style="display:flex; flex-direction:column; height:100%;">
        <div class="chat-header">
          <i class="ri-at-line header-icon"></i>
          <div class="header-title" id="headerName">User</div>
          <div class="header-toolbar">
            <i class="ri-phone-fill toolbar-icon call-btn" onclick="startCall()"></i>
            <i class="ri-vidicon-fill toolbar-icon toolbar-video" onclick="startCall()"></i>
            <i class="ri-pushpin-fill toolbar-icon"></i>
            <i class="ri-group-fill toolbar-icon" onclick="openGroupDetails()"></i>
            <!-- <i class="ri-question-mark toolbar-icon"></i> -->
          </div>
        </div>

        <div class="chat-messages" id="messagesArea">
          <!-- Messages go here -->
        </div>

        <div class="input-area">
          <div class="input-wrapper">
            <input id="messageInput" placeholder="Message @User" autocomplete="off" />
            <div class="input-actions">
              <div class="input-btn" onclick="toggleGifPicker()"><i class="ri-file-gif-line"></i></div>
              <div class="input-btn"><i class="ri-emotion-line"></i></div>
            </div>
          </div>
        </div>
        <!-- GIF Picker -->
        <div id="gifPicker"
          style="position:absolute; bottom:80px; right:20px; width:300px; height:350px; background:var(--bg-primary); border-radius:8px; display:none; flex-direction:column; box-shadow:0 0 10px rgba(0,0,0,0.5); z-index:100;">
          <input type="text" placeholder="Search Tenor" id="gifSearchInput" oninput="searchGIFs(this.value)"
            style="padding:10px; background:var(--bg-secondary); border:none; color:#fff; border-bottom:1px solid #222;">
          <div class="gif-grid" id="gifGrid"
            style="flex:1; overflow-y:auto; padding:5px; display:grid; grid-template-columns:1fr 1fr; gap:5px;"></div>
        </div>
      </div>
    </div>

    <!-- Call Overlay (Moved inside main-content) -->
    <div id="callOverlay">
      <div class="call-grid" id="callGrid"></div>
      <div class="call-controls">
        <div class="call-btn-circle" onclick="document.getElementById('callOverlay').classList.remove('active')"
          title="Minimize to Chat"><i class="ri-chat-3-fill"></i></div>
        <div class="call-btn-circle" onclick="toggleMute()" id="muteBtn"><i class="ri-mic-off-fill"></i></div>
        <div class="call-btn-circle" onclick="endCall()" style="background:var(--red);"><i
            class="ri-phone-end-fill"></i></div>
        <div class="call-btn-circle" onclick="toggleCamera()" id="camBtn"><i class="ri-camera-off-fill"></i></div>
        <div class="call-btn-circle" onclick="toggleScreenShare()"><i class="ri-computer-line"></i></div>
      </div>
    </div>
  </div>
  <!-- PiP Container -->
  <div id="pipContainer" onclick="restoreOverlay()"></div>
  </div>

  <div class="modal-overlay" id="serverModal">
    <div class="modal-box" style="padding:24px; width:400px;">
      <h2 style="text-align:center; margin-top:0;">Create a Server</h2>
      <p style="text-align:center; color:var(--text-muted); font-size:14px;">Your server is where you can hang out with
        your friends.</p>

      <div style="margin-bottom:20px;">
        <input id="serverNameInput" placeholder="Server Name"
          style="width:100%; padding:10px; background:var(--bg-tertiary); border:1px solid #111; color:#fff; border-radius:4px; margin-bottom:10px;">
        <button onclick="createServer()"
          style="width:100%; padding:12px; background:var(--brand); color:#fff; border:none; border-radius:4px; cursor:pointer;">Create</button>
      </div>

      <div style="text-align:center; margin-bottom:20px; font-size:12px; color:var(--text-muted);">OR</div>

      <h3 style="text-align:center; margin-top:0;">Join a Server</h3>
      <p style="text-align:center; color:var(--text-muted); font-size:14px;">Enter an invite code below to join an
        existing server.</p>
      <div style="margin-bottom:20px;">
        <input id="serverCodeInput" placeholder="Invite Code"
          style="width:100%; padding:10px; background:var(--bg-tertiary); border:1px solid #111; color:#fff; border-radius:4px; margin-bottom:10px;">
        <button onclick="joinServer()"
          style="width:100%; padding:12px; background:var(--green); color:#fff; border:none; border-radius:4px; cursor:pointer;">Join</button>
      </div>

      <div onclick="closeModal('serverModal')"
        style="text-align:center; cursor:pointer; font-size:14px; color:var(--text-muted);">Cancel</div>
    </div>
  </div>

  <!-- Server Settings Modal (Glass) -->
  <div class="modal-overlay" id="serverSettingsModal">
    <div class="glass-panel" style="width: 500px; padding: 30px; animation: fadeIn 0.2s ease-out;">
      <h3 style="margin-top:0; color:var(--header-primary); margin-bottom:20px;">Server Overview</h3>
      <div style="display:flex;">
        <div style="width:100px; text-align:center; margin-right:20px;">
          <div id="serverSettingsIcon"
            style="width:80px; height:80px; border-radius:50%; background:var(--brand); display:flex; align-items:center; justify-content:center; font-size:30px; margin:0 auto 10px;">
            S</div>
          <div style="font-size:12px; color:var(--text-muted);">Remove Icon</div>
        </div>
        <div style="flex:1;">
          <div
            style="margin-bottom:8px; font-size:12px; font-weight:700; color:var(--text-muted); text-transform:uppercase;">
            Server Name</div>
          <input id="serverSettingsNameInput" class="input-wrapper"
            style="width:100%; margin-bottom:20px; background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border);">

          <div style="border-top: 1px solid var(--glass-border); padding-top:20px; margin-top:10px;">
            <button onclick="saveServerSettings()"
              style="background:var(--green); color:#fff; border:none; padding:10px 20px; border-radius:4px; margin-right:10px; cursor:pointer;">Save
              Changes</button>
            <button onclick="closeModal('serverSettingsModal')"
              style="background:transparent; color:var(--text-normal); border:none; padding:10px 20px; cursor:pointer;">Cancel</button>
          </div>

          <div style="border-top: 1px solid var(--glass-border); padding-top:20px; margin-top:20px;">
            <div
              style="font-size:12px; font-weight:700; color:var(--text-muted); text-transform:uppercase; margin-bottom:10px;">
              Danger Zone</div>
            <button onclick="deleteServer()"
              style="border:1px solid var(--red); color:var(--red); background:transparent; padding:10px 20px; border-radius:4px; cursor:pointer;">Delete
              Server</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Friends View (Dedicated Full Screen) -->
  <div id="friendsView" class="hidden"
    style="position:absolute; top:48px; left:0; right:0; bottom:0; background:var(--bg-primary); z-index:10; display:flex; flex-direction:column;">
    <div style="padding: 20px 30px; border-bottom: 1px solid rgba(0,0,0,0.1);">
      <div style="display:flex; align-items:center;">
        <i class="ri-friends-fill" style="font-size:24px; color:var(--text-muted); margin-right:10px;"></i>
        <h2 style="margin:0; color:var(--header-primary);">Friends</h2>
        <div style="margin-left:30px; display:flex; gap:20px;">
          <div style="color:var(--header-primary); font-weight:600; cursor:pointer;">All</div>
          <div style="color:var(--text-muted); cursor:pointer;">Online</div>
          <div style="color:var(--text-muted); cursor:pointer;">Pending</div>
          <div style="color:var(--text-muted); cursor:pointer;">Blocked</div>
          <div style="color:var(--green); cursor:pointer;">Add Friend</div>
        </div>
      </div>
    </div>
    <div style="flex:1; padding:30px; overflow-y:auto;" id="friendsGrid">
      <!-- Populated by JS -->
      <div style="text-align:center; margin-top:100px;">
        <div style="width:200px; height:150px; background:var(--bg-tertiary); margin:0 auto 20px; border-radius:8px;">
        </div>
        <div style="color:var(--text-muted);">Wumpus is waiting on friends. You don't have any yet!</div>
      </div>
    </div>
  </div>

  <!-- Modals -->
  <div class="modal-overlay" id="newChatModal">
    <div class="modal-box" style="padding:24px;">
      <h3 style="margin-top:0; color:var(--header-primary); text-transform:uppercase; font-size:12px;">Create DM</h3>
      <input id="newChatInput" placeholder="Enter username"
        style="width:100%; padding:10px; background:var(--bg-tertiary); border:1px solid #000; color:#fff; border-radius:4px; outline:none; margin-bottom:10px;">
      <div style="font-size:12px; color:var(--text-muted); cursor:pointer; margin-bottom:20px;"
        onclick="toggleGroupMode()">Switch to Group DM</div>
      <input id="newGroupMembers" placeholder="Members (comma sep)"
        style="display:none; width:100%; padding:10px; background:var(--bg-tertiary); border:1px solid #000; color:#fff; border-radius:4px; outline:none; margin-bottom:10px;">
      <button onclick="startNewChat()"
        style="width:100%; padding:10px; background:var(--brand); color:#fff; border:none; border-radius:4px; cursor:pointer;">Create</button>
      <div onclick="closeModal('newChatModal')"
        style="text-align:center; margin-top:10px; cursor:pointer; font-size:12px;">Cancel</div>
    </div>
  </div>

  <div class="modal-overlay" id="settingsModal">
    <div class="glass-panel"
      style="width: 800px; height: 600px; display:flex; overflow:hidden; animation: fadeIn 0.2s ease-out;">
      <!-- Sidebar -->
      <div
        style="width: 230px; background: rgba(0,0,0,0.2); padding: 20px 10px; display:flex; flex-direction:column; border-right: 1px solid var(--glass-border);">
        <div
          style="font-size: 12px; font-weight: 700; color: var(--text-muted); padding: 6px 10px; margin-bottom: 8px;">
          USER SETTINGS</div>
        <div class="nav-item active" style="margin-bottom: 2px;">My Account</div>
        <div class="nav-item" style="margin-bottom: 2px; opacity:0.5; pointer-events:none;">Profiles</div>
        <div class="nav-item" style="margin-bottom: 2px; opacity:0.5; pointer-events:none;">Privacy & Safety</div>
        <div class="nav-item" style="margin-bottom: 2px; opacity:0.5; pointer-events:none;">Appearance</div>
        <div style="border-bottom: 1px solid var(--glass-border); margin: 8px 10px;"></div>
        <div class="nav-item" onclick="closeModal('settingsModal')" style="color:var(--red); margin-top:auto;"><i
            class="ri-logout-box-line" style="margin-right:8px;"></i>Log Out</div>
      </div>

      <!-- Content -->
      <div style="flex:1; padding: 40px; overflow-y:auto; position:relative;">
        <h2 style="color:var(--header-primary); margin-bottom: 20px;">My Account</h2>

        <!-- Profile Card -->
        <div class="glass-panel" style="background: rgba(0,0,0,0.2); padding: 20px; display:flex; margin-bottom: 40px;">
          <div class="user-avatar"
            style="width: 80px; height: 80px; font-size: 32px; margin-right: 20px; background: var(--brand);">
            <span id="settingsAvatarDisplay">?</span>
          </div>
          <div style="flex:1;">
            <div style="color:var(--header-primary); font-size: 20px; font-weight: 600; margin-bottom: 4px;"
              id="settingsNameDisplay">User</div>
            <div style="color:var(--text-normal); font-size: 14px;">#<span style="color:var(--text-muted);">0000</span>
            </div>
            <button
              style="margin-top: 10px; background: var(--brand); color: #fff; border: none; padding: 6px 16px; border-radius: 4px; font-size: 14px; cursor: pointer;">Edit
              User Profile</button>
          </div>
        </div>

        <div style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 16px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 16px;">
            <div>
              <div style="color:var(--text-muted); font-size: 12px; font-weight: 700; text-transform: uppercase;">
                Username</div>
              <div style="color:var(--text-normal); font-size: 16px;">
                <span id="settingsUsernameText">User</span>
                <span style="color:var(--text-muted);">#0000</span>
              </div>
            </div>
            <button
              style="background: #4f545c; color: #fff; border: none; padding: 6px 16px; border-radius: 4px; font-size: 14px; cursor: pointer;"
              onclick="document.getElementById('editUsernameBlock').style.display='block'">Edit</button>
          </div>

          <div id="editUsernameBlock"
            style="display:none; margin-top: 10px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px;">
            <input id="settingsUsernameInput" class="input-wrapper"
              style="width:100%; margin-bottom:10px; background: #202225; border: 1px solid #000;"
              placeholder="New Username">
            <div style="text-align:right;">
              <button onclick="document.getElementById('editUsernameBlock').style.display='none'"
                style="background:transparent; color:var(--text-normal); border:none; padding:8px 16px; cursor:pointer;">Cancel</button>
              <button onclick="saveSettings()"
                style="background:var(--brand); color:#fff; border:none; padding:8px 16px; border-radius:4px; cursor:pointer;">Save</button>
            </div>
          </div>

          <div style="display:flex; justify-content:space-between; align-items:center; margin-top: 16px;">
            <div>
              <div style="color:var(--text-muted); font-size: 12px; font-weight: 700; text-transform: uppercase;">Email
              </div>
              <div style="color:var(--text-normal); font-size: 16px;">******@***.com</div>
            </div>
            <button
              style="background: transparent; color: var(--text-normal); border: none; padding: 6px 16px; font-size: 14px; cursor: not-allowed; opacity: 0.5;">Edit</button>
          </div>
        </div>

        <div style="position:absolute; top: 20px; right: 20px; cursor:pointer; color:var(--text-muted);"
          onclick="closeModal('settingsModal')">
          <div
            style="border: 2px solid var(--text-muted); border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;">
            <i class="ri-close-line" style="font-size: 24px;"></i>
          </div>
          <div style="text-align:center; font-size:12px; font-weight:600; margin-top:4px;">ESC</div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="groupDetailsModal">
    <div class="modal-box" style="padding:24px;">
      <h3 style="margin-top:0;">Group Members</h3>
      <div id="groupMembersList" style="max-height:200px; overflow-y:auto; margin-bottom:20px;"></div>
      <input id="groupAddUserInput" placeholder="Add User"
        style="width:100%; padding:8px; background:var(--bg-tertiary); border:none; color:#fff; margin-bottom:10px;">
      <button onclick="groupAddUser()"
        style="background:var(--brand); color:#fff; padding:8px 16px; border:none; border-radius:4px; cursor:pointer;">Add</button>
      <button onclick="closeModal('groupDetailsModal')"
        style="float:right; background:transparent; color:#fff; border:none; cursor:pointer;">Close</button>
    </div>
  </div>

  <div class="modal-overlay" id="nicknameModal">
    <!-- Simplified nickname/report modal -->
    <div class="modal-box" style="padding:24px;">
      <h3>User Actions</h3>
      <input type="hidden" id="nicknameTarget">
      <button onclick="confirmBlockUser()"
        style="width:100%; padding:10px; background:var(--red); color:#fff; border:none; border-radius:4px; cursor:pointer; margin-bottom:10px;">Block
        User</button>
      <button onclick="closeModal('nicknameModal')"
        style="width:100%; padding:10px; background:grey; color:#fff; border:none; border-radius:4px; cursor:pointer;">Cancel</button>
    </div>
  </div>


  <!-- SCRIPTS -->
  <script src="js/socketio.js"></script>
  <script>
    // --- APP LOGIC ADAPTED FROM ORIGINAL ---

    const socket = io({ path: "/profiles/socket.io/", auth: { username: localStorage.getItem("void_username") || null }, transports: ["websocket"] });

    let myId = null;
    let friends = [];
    let groups = {};
    let activeChatKey = null; // type:id
    let isGroupMode = false;
    let pinned = []; // Not really used in UI but kept for data compatibility
    let nicknames = {};
    let activeCalls = {};

    // DOM Elements
    const chatList = document.getElementById("chatList");
    const messagesArea = document.getElementById("messagesArea");
    const messageInput = document.getElementById("messageInput");
    const headerName = document.getElementById("headerName");
    const myUsernameDisplay = document.getElementById("myUsernameDisplay");
    const myAvatarDisplay = document.getElementById("myAvatarDisplay");

    // E2EE & Utils from original
    function arrayBufferToBase64(buffer) { let binary = ''; const bytes = new Uint8Array(buffer); for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]); return window.btoa(binary); }
    function base64ToUint8Array(base64) { const binary = window.atob(base64); const bytes = new Uint8Array(binary.length); for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i); return bytes; }

    // ... Crypto functions (initE2EE, etc. - compacted for brevity but critical logic maintained) ...
    let myKeyPair = null;
    const sharedSecrets = {};
    const publicKeyCache = {};
    const pendingKeyRequests = {};

    async function initE2EE() {
      if (!myId) return;
      const keyName = `e2ee_keys_${myId}`;
      const stored = localStorage.getItem(keyName);
      if (stored) {
        try {
          const { pub, priv } = JSON.parse(stored);
          const publicKey = await window.crypto.subtle.importKey("jwk", pub, { name: "ECDH", namedCurve: "P-256" }, true, []);
          const privateKey = await window.crypto.subtle.importKey("jwk", priv, { name: "ECDH", namedCurve: "P-256" }, false, ["deriveKey"]);
          myKeyPair = { publicKey, privateKey };
        } catch (e) { localStorage.removeItem(keyName); }
      }
      if (!myKeyPair) {
        myKeyPair = await window.crypto.subtle.generateKey({ name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey"]);
        const pub = await window.crypto.subtle.exportKey("jwk", myKeyPair.publicKey);
        const priv = await window.crypto.subtle.exportKey("jwk", myKeyPair.privateKey);
        localStorage.setItem(keyName, JSON.stringify({ pub, priv }));
      }
      const pubKeyRaw = await window.crypto.subtle.exportKey("spki", myKeyPair.publicKey);
      const pubKeyB64 = arrayBufferToBase64(pubKeyRaw);
      socket.emit("registerPublicKey", { publicKey: pubKeyB64 });
    }

    async function fetchPublicKey(target) {
      if (publicKeyCache[target] !== undefined) return publicKeyCache[target];
      if (pendingKeyRequests[target]) return new Promise(resolve => pendingKeyRequests[target].push(resolve));
      pendingKeyRequests[target] = [];
      const promise = new Promise(resolve => {
        const timeout = setTimeout(() => { resolve(null); }, 5000);
        pendingKeyRequests[target].push((key) => { clearTimeout(timeout); resolve(key); });
      });
      socket.emit("getPublicKey", { targetUsername: target });
      return promise;
    }

    socket.on("publicKey", ({ username, publicKey }) => {
      publicKeyCache[username] = publicKey;
      if (pendingKeyRequests[username]) { pendingKeyRequests[username].forEach(r => r(publicKey)); delete pendingKeyRequests[username]; }
    });

    async function getSharedSecret(target, targetPubKeyB64) {
      if (sharedSecrets[target]) return sharedSecrets[target];
      if (!targetPubKeyB64) return null;
      const pubKeyRaw = base64ToUint8Array(targetPubKeyB64);
      const targetPubKey = await window.crypto.subtle.importKey("spki", pubKeyRaw, { name: "ECDH", namedCurve: "P-256" }, true, []);
      const secret = await window.crypto.subtle.deriveKey({ name: "ECDH", public: targetPubKey }, myKeyPair.privateKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
      sharedSecrets[target] = secret;
      return secret;
    }

    async function encryptMessage(text, target) {
      try {
        const publicKey = await fetchPublicKey(target);
        if (!publicKey) return { encrypted: false, text };
        const secret = await getSharedSecret(target, publicKey);
        if (!secret) return { encrypted: false, text };
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encoded = new TextEncoder().encode(text);
        const encrypted = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, secret, encoded);
        const combined = new Uint8Array(iv.length + encrypted.byteLength);
        combined.set(iv);
        combined.set(new Uint8Array(encrypted), iv.length);
        return { encrypted: true, data: arrayBufferToBase64(combined.buffer) };
      } catch (e) { return { encrypted: false, text }; }
    }

    async function decryptMessage(entry, forcedTarget) {
      if (!entry.isEncrypted || !entry.data) return entry.text;
      const target = forcedTarget || entry.from;
      try {
        const publicKey = await fetchPublicKey(target);
        if (!publicKey) return "[no key]";
        const secret = await getSharedSecret(target, publicKey);
        if (!secret) return "[secret failure]";
        const combined = base64ToUint8Array(entry.data);
        const iv = combined.slice(0, 12);
        const data = combined.slice(12);
        const decrypted = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv }, secret, data);
        return new TextDecoder().decode(decrypted);
      } catch (e) { return "[lock failure]"; }
    }

    // UI HELPER FUNCTIONS
    function getDisplayName(id, isGroup = false) { if (isGroup) return groups[id]?.label || id; return nicknames[id] || id; }

    let servers = []; // populated from init

    function renderServerRail() {
      // Server Rail
      const rail = document.querySelector(".server-rail");
      rail.innerHTML = `
            <div class="server-icon home ${!activeChatKey || activeChatKey.startsWith('dm:') || activeChatKey.startsWith('group:') ? 'active' : ''}" id="homeBtn" onclick="backToSafeList()">
                <i class="ri-discord-fill"></i>
            </div>
            <div class="server-separator"></div>
        `;

      servers.forEach(s => {
        const isActive = activeChatKey && activeChatKey.startsWith(`server:${s.id}`);
        const activeCallKey = Object.keys(activeCalls).find(k => k.startsWith(s.id)); // Check for any active call in server

        const el = document.createElement("div");
        el.className = `server-icon ${isActive ? 'active' : ''}`;
        el.style.position = "relative";
        el.innerText = s.name.substring(0, 2).toUpperCase();

        if (activeCallKey) {
          const indicator = document.createElement("div");
          indicator.style.cssText = "position:absolute; bottom:-2px; right:-2px; width:12px; height:12px; background:var(--green); border-radius:50%; border:2px solid var(--bg-secondary); box-shadow:0 0 4px var(--green);";
          el.appendChild(indicator);
        }

        el.onclick = () => openServer(s.id);
        rail.appendChild(el);
      });

      const addBtn = document.createElement("div");
      addBtn.className = "server-icon";
      addBtn.style.color = "var(--green)";
      addBtn.style.background = "var(--bg-primary)";
      addBtn.innerHTML = '<i class="ri-add-line"></i>';
      addBtn.onclick = () => document.getElementById("serverModal").classList.add("active");
      rail.appendChild(addBtn);
    }

    function renderList() {
      const nav = document.getElementById("chatList");
      const dmHeader = document.querySelector(".dm-header");
      const friendsItem = document.querySelector(".nav-item .ri-user-smile-line")?.parentElement.parentElement;

      nav.innerHTML = "";

      if (activeChatKey && activeChatKey.startsWith("server:")) {
        // Hide DM specific UI
        if (dmHeader) dmHeader.style.display = 'none';
        if (friendsItem) friendsItem.style.display = 'none';

        // Render Channels
        const [_, serverId, channelId] = activeChatKey.split(":");
        const server = servers.find(s => s.id === serverId);

        if (server) {
          // Header
          const header = document.querySelector(".sidebar-header");
          header.innerHTML = `
            <div style="font-weight:bold; display:flex; justify-content:space-between; align-items:center; width:100%;">
                <span>${server.name}</span>
                <div style="display:flex;">
                    ${server.owner === myId ? `<i class="ri-settings-3-fill" style="cursor:pointer; color:var(--text-muted); margin-right:10px;" onclick="openServerSettings('${serverId}')" title="Server Settings"></i>` : ''}
                    ${server.owner !== myId ? `<i class="ri-logout-box-r-line" style="cursor:pointer; color:var(--red);" onclick="leaveServer('${serverId}')" title="Leave Server"></i>` : ''}
                </div>
            </div>`;

          // Channels (Hardcoded for now as per server.js default)
          // Text
          const textCh = document.createElement("div");
          textCh.className = `nav-item ${channelId === 'general' ? 'active' : ''}`;
          textCh.innerHTML = `<div style="margin-right:8px; color:var(--text-muted); font-size:18px;">#</div> general`;
          textCh.onclick = () => openChat('server', `${serverId}:general`);
          nav.appendChild(textCh);

          // Voice
          const voiceCh = document.createElement("div");
          voiceCh.className = `nav-item ${channelId === 'voice' ? 'active' : ''}`;
          voiceCh.innerHTML = `<div style="margin-right:8px; color:var(--text-muted);"><i class="ri-volume-up-line"></i></div> General`;
          voiceCh.onclick = () => startServerCall(serverId, 'voice');

          // Check if active call in this channel/server
          // calls are keyed by groupId or dmKey
          // server call key logic in server.js: `${groupId}:${channelId}`
          const callKey = `${serverId}:voice`; // assuming 'voice' is the channelId used
          // Wait, server.js uses `groupId` as callId if group, or `groupId:channelId` if provided.
          // let's check activeCalls
          // We need to match what server.js sends.
          // For now, let's look for any key starting with serverId
          const activeCallKey = Object.keys(activeCalls).find(k => k.startsWith(serverId));
          if (activeCallKey) {
            // Show participants?
            const parts = activeCalls[activeCallKey].participants;
            if (parts.length > 0) {
              const ul = document.createElement("div");
              ul.style.marginLeft = "20px";
              ul.style.fontSize = "12px";
              parts.forEach(p => {
                const li = document.createElement("div");
                li.style.display = "flex"; li.style.alignItems = "center"; li.style.padding = "2px 0";
                li.innerHTML = `<div style="width:20px; height:20px; border-radius:50%; background:var(--bg-tertiary); margin-right:5px; display:flex; justify-content:center; align-items:center; font-size:10px;">${p[0].toUpperCase()}</div> ${p}`;
                ul.appendChild(li);
              });
              nav.appendChild(ul);
            }
          }

          nav.appendChild(voiceCh);

          // Invite Code
          const invite = document.createElement("div");
          invite.style.marginTop = "auto";
          invite.style.padding = "10px";
          invite.style.fontSize = "12px";
          invite.style.color = "var(--text-muted)";
          invite.style.userSelect = "text";
          invite.innerHTML = `Invite Code: <span style="color:var(--text-normal); font-family:monospace; background:var(--bg-tertiary); padding:2px 4px; border-radius:4px;">${server.code || 'Loading...'}</span>`;
          nav.appendChild(invite);
        }
        renderServerRail();
        return;
      }

      // Restore Home UI
      if (dmHeader) dmHeader.style.display = 'flex';
      if (friendsItem) {
        friendsItem.style.display = 'flex';
        friendsItem.onclick = showFriendsView;
        // Check if Friends View is active
        if (!document.getElementById("friendsView").classList.contains("hidden")) {
          friendsItem.classList.add("active");
        } else {
          friendsItem.classList.remove("active");
        }
      }

      // Restore Home Header
      document.querySelector(".sidebar-header").innerHTML = `<button class="search-btn" onclick="showNewChatModal()">Find or start a conversation</button>`;

      let allItems = [];
      Object.values(groups).forEach(g => allItems.push({ type: 'group', id: g.id, label: g.label }));
      friends.forEach(f => allItems.push({ type: 'dm', id: f, label: f }));

      allItems.forEach(item => {
        const key = `${item.type}:${item.id}`;
        const isActive = activeChatKey === key;
        const el = document.createElement("div");
        el.className = `nav-item ${isActive ? 'active' : ''}`;
        el.onclick = () => openChat(item.type, item.id);

        const callKey = item.type === 'dm' ? `dm:${[myId, item.id].sort().join('|')}` : item.id;
        const callActive = activeCalls[callKey];

        el.innerHTML = `
                <div class="nav-item-avatar" style="${item.type === 'group' ? 'background:var(--brand);' : ''}">
                    ${getDisplayName(item.id, item.type === 'group')[0].toUpperCase()}
                    ${callActive ? '<div style="position:absolute; width:10px; height:10px; background:var(--green); border-radius:50%; border:2px solid var(--bg-secondary); bottom:-2px; right:-2px;"></div>' : ''}
                </div>
                <div style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                    ${getDisplayName(item.id, item.type === 'group')}
                </div>
            `;
        nav.appendChild(el);
      });

      renderServerRail();
    }

    function openServer(serverId) {
      openChat('server', `${serverId}:general`);
    }

    function openChat(type, id) {
      if (type === 'server') {
        activeChatKey = `server:${id}`;
        const [serverId, channelId] = id.split(":");
        socket.emit("getServer", { serverId });
      } else {
        activeChatKey = `${type}:${id}`;
      }

      document.getElementById("homeBtn").classList.remove("active");
      document.getElementById("emptyState").classList.add("hidden");
      document.getElementById("chatInterface").classList.remove("hidden");

      if (type === 'server') {
        const [serverId, channelId] = id.split(":");
        const s = servers.find(s => s.id === serverId);
        headerName.textContent = `#${channelId}`;
        messageInput.placeholder = `Message #${channelId}`;
      } else {
        const label = getDisplayName(id, type === 'group');
        headerName.textContent = label;
        messageInput.placeholder = `Message ${type === 'group' ? '#' + label : '@' + label}`;
      }

      renderList();

      if (type === 'group') socket.emit("getGroup", { groupId: id });
      else if (type === 'dm') {
        socket.emit("getDM", { target: id });
        socket.emit("markRead", { target: id });
      }
      messagesArea.innerHTML = "<div style='padding:20px; text-align:center;'>Loading...</div>";
    }

    function backToSafeList() {
      activeChatKey = null;
      document.getElementById("homeBtn").classList.add("active");
      document.getElementById("chatInterface").classList.add("hidden");
      document.getElementById("emptyState").classList.remove("hidden");
      renderList();
    }

    let renderSequence = 0;
    async function renderMessages(history, isGroup = false, append = false) {
      const seq = ++renderSequence;
      if (!history) return;
      if (!append) messagesArea.innerHTML = "";

      // Grouping logic
      let lastUser = null;
      let lastTimestamp = 0;

      for (let i = 0; i < history.length; i++) {
        const entry = history[i];
        const isMe = entry.from === myId;
        const isSystem = entry.isSystem || entry.from === "System";

        if (isSystem) {
          const sysDiv = document.createElement("div");
          sysDiv.style.cssText = "text-align:center; padding:10px; color:var(--text-muted); font-size:12px;";
          sysDiv.textContent = ` ${entry.text} `;
          messagesArea.appendChild(sysDiv);
          lastUser = null;
          continue;
        }

        let text = entry.text;
        if (entry.isEncrypted) {
          try {
            text = await decryptMessage(entry, isMe ? (activeChatKey ? activeChatKey.split(':')[1] : null) : entry.from);
          } catch (e) { }
        }

        let contentElement;
        if (text && text.startsWith("[gif]")) {
          contentElement = document.createElement("img");
          contentElement.src = text.substring(5);
          contentElement.style.maxWidth = "250px";
          contentElement.style.borderRadius = "4px";
          contentElement.style.marginTop = "5px";
          contentElement.loading = "lazy";
        } else {
          contentElement = document.createTextNode(text || "");
        }

        // Check if we bundle with previous message
        // Same user, less than 5 minutes diff
        const time = entry.ts || Date.now(); // Assuming history has timestamps, default to now if missing
        // Fix: server.js doesn't seem to explicitly send `ts` in all history logic viewed, but usually DB has it. 
        // If missing, grouping might look odd.

        const isContinuation = (entry.from === lastUser);

        if (isContinuation) {
          // Append to last message group
          const groups = messagesArea.getElementsByClassName("message-group");
          const lastGroup = groups[groups.length - 1];
          const contentDiv = lastGroup.querySelector(".message-content");
          const body = document.createElement("div");
          body.className = "message-body";
          body.appendChild(contentElement);
          contentDiv.appendChild(body);
        } else {
          const div = document.createElement("div");
          div.className = "message-group";

          const avatar = document.createElement("div");
          avatar.className = "message-avatar";
          avatar.textContent = getAvatarLabel(entry.from);
          avatar.onclick = () => openNicknameModal(entry.from);

          const content = document.createElement("div");
          content.className = "message-content";

          const header = document.createElement("div");
          header.className = "message-header";

          const username = document.createElement("span");
          username.className = "message-username";
          username.textContent = entry.from;
          username.onclick = () => openNicknameModal(entry.from);
          if (isMe) username.style.color = "var(--brand)";

          const timestamp = document.createElement("span");
          timestamp.className = "message-timestamp";
          timestamp.textContent = new Date().toLocaleTimeString();

          header.appendChild(username);
          header.appendChild(timestamp);

          const body = document.createElement("div");
          body.className = "message-body";
          body.appendChild(contentElement);

          content.appendChild(header);
          content.appendChild(body);

          div.appendChild(avatar);
          div.appendChild(content);

          messagesArea.appendChild(div);
        }
        lastUser = entry.from;
      }
      messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    function getAvatarLabel(id) {
      return (nicknames[id] || id)[0].toUpperCase();
    }

    // Input Handling
    async function sendMessage() {
      const text = messageInput.value.trim();
      if (!text || !activeChatKey) return;

      if (activeChatKey.startsWith("server:")) {
        const [_, serverId, channelId] = activeChatKey.split(":");
        socket.emit("sendServerMsg", { serverId, channelId, text });
        messageInput.value = "";
        return;
      }

      const [type, id] = activeChatKey.split(":");
      if (type === 'dm') {
        const { encrypted, data } = await encryptMessage(text, id);
        socket.emit("sendDM", { target: id, text: encrypted ? '[encrypted]' : text, isEncrypted: encrypted, data });
      } else {
        socket.emit("sendGroup", { groupId: id, text });
      }
      messageInput.value = "";
    }

    messageInput.addEventListener("keypress", (e) => { if (e.key === "Enter") sendMessage(); });

    // Server Logic
    function createServer() {
      const name = document.getElementById("serverNameInput").value.trim();
      if (name) socket.emit("createServer", { name });
      closeModal("serverModal");
    }

    function joinServer() {
      const code = document.getElementById("serverCodeInput").value.trim();
      if (code) socket.emit("joinServer", { code });
      closeModal("serverModal");
    }

    socket.on("serverCreated", ({ server }) => {
      // Refresh handled by init or manual push
      // For now, let's rely on init re-sending or push to list
      window.location.reload(); // Simple refresh to get new state safe and sound
    });

    socket.on("serverJoined", ({ server }) => {
      window.location.reload();
    });

    socket.on("serverMsg", ({ serverId, channelId, entry }) => {
      if (activeChatKey === `server:${serverId}:${channelId}`) {
        renderMessages([entry], true);
      }
    });

    socket.on("serverData", ({ server, messages }) => {
      // Cache server data?
      // For now, just render if active
      // logic handled in renderList/openChat
    });

    // Modals
    function showNewChatModal() { document.getElementById("newChatModal").classList.add("active"); }
    function closeModal(id) { document.getElementById(id).classList.remove("active"); }
    function toggleGroupMode() { isGroupMode = !isGroupMode; document.getElementById("newGroupMembers").style.display = isGroupMode ? 'block' : 'none'; }
    function startNewChat() {
      const val = document.getElementById("newChatInput").value.trim();
      if (!val) return;
      if (isGroupMode) {
        const members = document.getElementById("newGroupMembers").value.split(",").map(s => s.trim());
        socket.emit("createGroup", { label: val, members });
      } else {
        if (!friends.includes(val)) { friends.push(val); renderList(); }
        openChat("dm", val);
      }
      closeModal("newChatModal");
    }

    function showSettings() {
      document.getElementById("settingsModal").classList.add("active");
      document.getElementById("settingsUsernameInput").value = myId;
      document.getElementById("settingsUsernameText").textContent = myId;
      document.getElementById("settingsNameDisplay").textContent = myId;
      document.getElementById("settingsAvatarDisplay").textContent = myId[0].toUpperCase();
    }
    function saveSettings() {
      const newName = document.getElementById("settingsUsernameInput").value.trim();
      if (newName && newName !== myId) socket.emit("changeUsername", { newName });
      closeModal("settingsModal");
    }

    // Server Settings JS
    function openServerSettings(serverId) {
      const s = servers.find(sv => sv.id === serverId);
      if (!s) return;
      if (s.owner !== myId) { alert("Only the owner can manage server settings."); return; }

      document.getElementById("serverSettingsModal").classList.add("active");
      document.getElementById("serverSettingsNameInput").value = s.name;
      document.getElementById("serverSettingsIcon").textContent = s.icon || s.name[0];

      // Store current editing server
      window.editingServerId = serverId;
    }

    function saveServerSettings() {
      const name = document.getElementById("serverSettingsNameInput").value.trim();
      if (name) {
        socket.emit("updateServer", { serverId: window.editingServerId, updates: { name } });
      }
      closeModal("serverSettingsModal");
    }

    function deleteServer() {
      if (confirm("Are you sure you want to delete this server? This action cannot be undone.")) {
        socket.emit("deleteServer", { serverId: window.editingServerId });
        closeModal("serverSettingsModal");
      }
    }

    // Friends View Logic
    function showFriendsView() {
      activeChatKey = null;
      document.getElementById("homeBtn").classList.add("active");

      // Hide Chat Interface, Show Friends View
      document.getElementById("chatInterface").classList.add("hidden");
      document.getElementById("emptyState").classList.add("hidden");
      document.getElementById("friendsView").classList.remove("hidden");

      renderFriendsGrid();
      renderList(); // Update sidebar active state
    }

    function renderFriendsGrid() {
      const grid = document.getElementById("friendsGrid");
      if (!friends.length) {
        grid.innerHTML = `
              <div style="text-align:center; margin-top:100px;">
                  <div style="width:200px; height:150px; background:var(--bg-tertiary); margin:0 auto 20px; border-radius:8px;"></div>
                  <div style="color:var(--text-muted);">Wumpus is waiting on friends. You don't have any yet!</div>
              </div>`;
        return;
      }

      grid.innerHTML = "";
      friends.forEach(f => {
        const el = document.createElement("div");
        el.style.cssText = "display:flex; align-items:center; padding:10px; border-top:1px solid rgba(255,255,255,0.06); cursor:pointer;";
        el.onmouseover = () => el.style.background = "rgba(255,255,255,0.02)";
        el.onmouseout = () => el.style.background = "transparent";

        el.innerHTML = `
                <div class="user-avatar" style="width:32px; height:32px; font-size:14px; margin-right:12px; background:var(--bg-secondary);">${f[0].toUpperCase()}</div>
                <div style="flex:1;">
                    <div style="font-weight:600; color:var(--header-primary);">${f}</div>
                    <div style="font-size:12px; color:var(--text-muted);">Online</div>
                </div>
                <div style="display:flex; gap:10px;">
                    <div style="background:var(--bg-secondary); padding:8px; border-radius:50%; cursor:pointer;" onclick="openChat('dm', '${f}')" title="Message"><i class="ri-message-2-fill"></i></div>
                    <div style="background:var(--bg-secondary); padding:8px; border-radius:50%; cursor:pointer;" title="More"><i class="ri-more-2-fill"></i></div>
                </div>
            `;
        grid.appendChild(el);
      });
    }

    // Group Details
    function openGroupDetails() {
      const [type, id] = activeChatKey?.split(':') || [];
      if (type !== 'group') return;
      document.getElementById("groupDetailsModal").classList.add("active");
      const g = groups[id];
      const list = document.getElementById("groupMembersList");
      list.innerHTML = "";
      g.members.forEach(m => {
        const d = document.createElement("div");
        d.style.padding = "5px"; d.style.borderBottom = "1px solid #333";
        d.innerHTML = `${m} ${m === myId ? '(You)' : ''} ${m !== myId ? `<span style='float:right; color:red; cursor:pointer;' onclick="socket.emit('kickFromGroup', {groupId:'${id}', targetUsername:'${m}'})">Kick</span>` : ''}`;
        list.appendChild(d);
      });
    }

    function groupAddUser() {
      const [type, id] = activeChatKey?.split(':') || [];
      const target = document.getElementById("groupAddUserInput").value.trim();
      if (target && type === 'group') socket.emit("addToGroup", { groupId: id, targetUsername: target });
    }

    // Modal helpers
    function openNicknameModal(target) {
      document.getElementById("nicknameModal").classList.add("active");
      document.getElementById("nicknameTarget").value = target;
    }
    function confirmBlockUser() {
      const t = document.getElementById("nicknameTarget").value;
      if (confirm(`Block ${t}?`)) socket.emit("blockUser", { target: t });
      closeModal("nicknameModal");
    }

    // Sockets Init
    socket.on("init", async data => {
      myId = data.username;
      localStorage.setItem("void_username", myId);
      myUsernameDisplay.textContent = myId;
      myAvatarDisplay.textContent = myId[0].toUpperCase();

      await initE2EE();
      friends = data.friends || [];
      groups = {};
      (data.groups || []).forEach(g => groups[g.id] = g);
      servers = data.servers || [];
      activeCalls = data.activeCalls || {};

      renderList();
    });

    socket.on("dmHistory", ({ key, history }) => {
      // Only render if active
      // key format: dm:user1|user2
      const parts = key.split('|');
      const other = parts.find(p => p !== myId) || parts[0];
      if (activeChatKey === `dm:${other}`) renderMessages(history);
    });

    socket.on("dm", async ({ key, entry }) => {
      const parts = key.split('|');
      const other = parts.find(p => p !== myId) || parts[0];
      if (!friends.includes(other)) { friends.push(other); renderList(); }

      if (activeChatKey === `dm:${other}`) {
        // Append single message logic (simplified: re-render or append)
        // For now, re-requesting history or manual append?
        // Let's manually append to avoid flash
        // But we need history structure. Let's just create a wrapper array
        // Optimization: Append directly
        const history = [entry]; // renderMessages handles single entry loop

        // To properly group, renderMessages needs to know previous state or we inspect DOM
        // renderMessages implementation above appends if contiguous
        // Append directly
        renderMessages([entry], false, true);

        if (entry.from !== myId) {
          socket.emit("markRead", { target: other });
        }
      }
    });

    socket.on("groupHistory", ({ history }) => renderMessages(history, true));
    socket.on("groupMsg", ({ groupId, entry }) => {
      if (activeChatKey === `group:${groupId}`) renderMessages([entry], true);
    });

    socket.on("groupUpdated", g => {
      groups[g.id] = g;
      renderList();
    });

    // Call Status Updates
    socket.on("call-status-changed", ({ callId, type, isActive, participants }) => {
      if (isActive) activeCalls[callId] = { type, participants };
      else delete activeCalls[callId];
      renderList();
    });

    // GIF logic
    const gifs = [
      "https://media.tenor.com/Crm5NdaA4oAAAAAj/hi-hello.gif",
      "https://media.tenor.com/Y7B1Q7Zlz18AAAAj/laughing-laugh.gif",
      "https://media.tenor.com/bXjXj2I9eRUAAAAj/thumbs-up-like.gif",
      "https://media.tenor.com/pQjV8yLp3yAAAAAj/heart-love.gif"
    ];
    function toggleGifPicker() {
      const p = document.getElementById("gifPicker");
      p.style.display = p.style.display === 'flex' ? 'none' : 'flex';
      if (p.style.display === 'flex') {
        const grid = document.getElementById("gifGrid");
        grid.innerHTML = "";
        gifs.forEach(url => {
          const img = document.createElement("img");
          img.src = url;
          img.style.width = "100%"; img.style.cursor = "pointer";
          img.onclick = () => {
            // Send GIF
            const [type, id] = activeChatKey?.split(":") || [];
            if (id) {
              socket.emit(type === 'dm' ? "sendDM" : "sendGroup", {
                [type === 'dm' ? 'target' : 'groupId']: id,
                text: `[gif]${url}`
              });
              toggleGifPicker();
            }
          };
          grid.appendChild(img);
        });
      }
    }

    // WebRTC Call Stub - keeping original logic roughly
    // Just need to ensure `startCall` triggers existing logic
    // We can copy-paste the `startCall` / `initiateConnection` etc from original file.
    // ... Copying WebRTC logic ...

    let localStream = null;
    let peers = {};
    const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
    let screenStream = null;

    async function startServerCall(serverId, channelId) {
      activeChatKey = `server:${serverId}:${channelId}`;
      await startCall();
    }

    async function startCall() {
      // If server channel, get context
      let contextName = "DM Call";
      if (activeChatKey && activeChatKey.startsWith("server:")) {
        contextName = "General / Server"; // Simplified
      }

      if (localStream && document.getElementById("callOverlay").classList.contains("active")) {
        // Already in call, maybe just show overlay
        document.getElementById("callOverlay").classList.add("active");
        return;
      }

      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        document.getElementById("callOverlay").classList.add("active");

        // Show Voice Panel
        document.getElementById("voicePanel").classList.add("active");
        document.getElementById("voiceChannelName").textContent = contextName;

        addVideo(localStream, myId, true);

        const [type, id] = activeChatKey ? activeChatKey.split(":") : ['dm', 'null'];

        if (type === 'server') {
          const [_, serverId, channelId] = activeChatKey.split(":");
          socket.emit("join-call", { groupId: serverId, isGroup: true, channelId }); // Reusing group logic for server for now
          // Note: server.js handles 'group' calls genericly.
          // We might need to ensure server.js treats serverId as groupId for signaling
        } else if (type === 'group') {
          socket.emit("join-call", { groupId: id, isGroup: true });
        } else {
          socket.emit("join-call", { groupId: id, isGroup: false, target: id });
          initiateConnection(id, false, null);
        }
      } catch (e) { console.error(e); alert("Failed to access media devices"); }
    }

    function addVideo(stream, userId, isLocal = false) {
      const grid = document.getElementById("callGrid");
      const div = document.createElement("div");
      div.className = "call-video-container";
      div.style.width = "300px"; div.style.height = "200px";

      const v = document.createElement("video");
      v.srcObject = stream; v.autoplay = true; if (isLocal) v.muted = true;
      v.style.width = "100%"; v.style.height = "100%"; v.style.objectFit = "cover";

      const overlay = document.createElement("div");
      overlay.className = "video-name-overlay";
      overlay.textContent = (nicknames[userId] || userId || "User");

      div.appendChild(v);
      div.appendChild(overlay);
      grid.appendChild(div);
      div.id = `vid_${userId}`;
    }

    function minimizeCall() {
      const overlay = document.getElementById("callOverlay");
      const pip = document.getElementById("pipContainer");
      const grid = document.getElementById("callGrid");

      overlay.classList.remove("active");
      pip.innerHTML = "";
      pip.style.display = 'block';

      // Find a remote video to show
      const videos = grid.getElementsByClassName("call-video-container");
      if (videos.length > 0) {
        let target = null;
        for (let div of videos) {
          const v = div.querySelector("video");
          // Heuristic: Local video is always muted. Remote is unmuted (unless deafened/muted manually).
          // Better: We assigned ID `vid_${userId}`. `myId` is global.
          if (div.id !== `vid_${myId}`) {
            target = div;
            break;
          }
        }
        if (!target && videos.length > 1) target = videos[1]; // fallback

        if (target) {
          pip.appendChild(target);
          pip.classList.add("active");
        }
      }
    }
    let isScreenSharing = false;
    async function toggleScreenShare() {
      if (!localStream) return;

      if (!isScreenSharing) {
        try {
          const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
          const screenTrack = screenStream.getVideoTracks()[0];

          // Replace track in localStream
          const senderFuncs = [];

          // Replace for all peers
          for (let id in peers) {
            const pc = peers[id];
            const sender = pc.getSenders().find(s => s.track.kind === 'video');
            if (sender) sender.replaceTrack(screenTrack);
          }

          // Update local view
          const localVid = document.querySelector(`#vid_${myId} video`);
          if (localVid) {
            localVid.srcObject = screenStream;
            // Local preview of screen share usually shouldn't be muted? optional.
          }

          screenTrack.onended = () => {
            if (isScreenSharing) toggleScreenShare(); // Stop if user stopped via browser UI
          };

          isScreenSharing = true;
          // Update button styling
          const btn = document.querySelector(".ri-computer-line").parentElement;
          if (btn) btn.style.color = "var(--green)";

          // Store original track to restore later? 
          // Actually getDisplayMedia replaces the stream. 
          // We need to keep the original camera track if we want to toggle back.
          // For simplicity, we might need to re-acquire user media to toggle back to cam.

        } catch (e) {
          console.error("Screen share failed", e);
        }
      } else {
        // Stop screen share, revert to camera
        isScreenSharing = false;
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        const camTrack = stream.getVideoTracks()[0];
        const audioTrack = stream.getAudioTracks()[0]; // Re-grab audio too just in case

        // Replace track in localStream object (to keep state)
        // Note: this creates a NEW stream object technically.
        localStream = stream;

        // Update peers
        for (let id in peers) {
          const pc = peers[id];
          const videoSender = pc.getSenders().find(s => s.track.kind === 'video');
          const audioSender = pc.getSenders().find(s => s.track.kind === 'audio');
          if (videoSender) videoSender.replaceTrack(camTrack);
          if (audioSender) audioSender.replaceTrack(audioTrack);
        }

        // Update local view
        const localVid = document.querySelector(`#vid_${myId} video`);
        if (localVid) {
          localVid.srcObject = stream;
          localVid.muted = true;
        }

        const btn = document.querySelector(".ri-computer-line").parentElement;
        if (btn) btn.style.color = "var(--text-normal)";
      }
    }

    function restoreOverlay() {
      const overlay = document.getElementById("callOverlay");
      const pip = document.getElementById("pipContainer");
      const grid = document.getElementById("callGrid");

      while (pip.children.length > 0) {
        grid.appendChild(pip.children[0]);
      }
      pip.classList.remove("active");
      pip.style.display = 'none';

      overlay.classList.add("active");
    }

    let isDeafened = false;
    function toggleDeafen() {
      isDeafened = !isDeafened;
      document.querySelectorAll("video").forEach(v => {
        // Keep local muted, toggle others
        if (v.parentElement.id === `vid_${myId}` || (localStream && v.srcObject === localStream)) {
          v.muted = true;
        } else {
          v.muted = isDeafened;
        }
      });

      const btn = document.querySelector(".ri-headphone-fill").parentElement;
      if (isDeafened) btn.style.color = "var(--red)";
      else btn.style.color = "var(--text-normal)";
    }

    function endCall() {
      if (localStream) localStream.getTracks().forEach(t => t.stop());
      localStream = null;
      document.getElementById("callOverlay").classList.remove("active");
      document.getElementById("voicePanel").classList.remove("active");

      const pip = document.getElementById("pipContainer");
      pip.classList.remove("active");
      pip.style.display = 'none';
      pip.innerHTML = "";

      document.getElementById("callGrid").innerHTML = "";
      Object.values(peers).forEach(p => p.close());
      peers = {};

      if (activeChatKey) {
        // Leave call logic
        const [type, id] = activeChatKey.split(":");
        const targetId = type === 'server' ? id.split(':')[0] : id;
        socket.emit("leave-call", { isGroup: type !== 'dm', target: targetId, groupId: targetId });
      }
    }

    function toggleMute() {
      if (localStream) {
        const t = localStream.getAudioTracks()[0];
        if (t) {
          t.enabled = !t.enabled;
          const isMuted = !t.enabled;

          // Update Sidebar Button
          const btn = document.getElementById("sidebarMuteBtn");
          if (btn) {
            if (isMuted) btn.style.color = "var(--red)";
            else btn.style.color = "var(--text-normal)";
          }

          // Update Overlay Button
          const ovBtn = document.getElementById("muteBtn");
          if (ovBtn) {
            if (isMuted) ovBtn.style.backgroundColor = "var(--red)";
            else ovBtn.style.backgroundColor = "#2f3136";
          }
        }
      }
    }
    function toggleCamera() {
      if (localStream) {
        const t = localStream.getVideoTracks()[0];
        if (t) t.enabled = !t.enabled;
      }
    }

    async function initiateConnection(target, isGroup, groupId) {
      if (peers[target]) return;
      const pc = new RTCPeerConnection(config);
      peers[target] = pc;
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      pc.onicecandidate = event => {
        if (event.candidate) socket.emit("call-signal", { target, signal: { type: 'candidate', candidate: event.candidate }, isGroup, groupId });
      };
      pc.ontrack = event => addVideo(event.streams[0], target);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit("call-signal", { target, signal: { type: 'offer', sdp: pc.localDescription }, isGroup, groupId });
    }

    socket.on("call-signal", async ({ from, signal, isGroup, groupId }) => {
      if (!localStream) {
        // Incoming Call Toast logic could go here
        return;
      }
      let pc = peers[from];
      if (!pc) {
        pc = new RTCPeerConnection(config);
        peers[from] = pc;
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        pc.onicecandidate = event => { if (event.candidate) socket.emit("call-signal", { target: from, signal: { type: 'candidate', candidate: event.candidate }, isGroup, groupId }); };
        pc.ontrack = event => addVideo(event.streams[0], from);
      }
      if (signal.type === 'offer') {
        await pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit("call-signal", { target: from, signal: { type: 'answer', sdp: pc.localDescription }, isGroup, groupId });
      } else if (signal.type === 'answer') {
        await pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
      } else if (signal.type === 'candidate') {
        await pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
      }
    });

    socket.on("call-status-changed", ({ callId, type, isActive, participants }) => {
      if (!activeCalls[callId]) activeCalls[callId] = { participants: [] };

      if (isActive) {
        activeCalls[callId] = { participants };
      } else {
        delete activeCalls[callId];
      }
      renderList();
    });

    socket.on("user-joined-call", ({ from, groupId }) => {
      if (localStream && activeChatKey === `group:${groupId}`) initiateConnection(from, true, groupId);
    });

    socket.on("user-left-call", ({ from }) => {
      if (peers[from]) { peers[from].close(); delete peers[from]; }
      const el = document.getElementById(`vid_${from}`);
      if (el) el.remove();
    });

    // GIF Picker
    let gifPickerOpen = false;
    function toggleGifPicker() {
      // Toggle UI
      let picker = document.getElementById("gifPicker");
      if (!picker) {
        picker = document.createElement("div");
        picker.id = "gifPicker";
        picker.style.cssText = "position:absolute; bottom:60px; right:20px; width:300px; height:400px; background:var(--bg-secondary); border-radius:8px; display:flex; flex-direction:column; padding:10px; z-index:100; box-shadow: 0 4px 15px rgba(0,0,0,0.5);";
        picker.innerHTML = `
                <input type="text" id="gifSearchInput" placeholder="Search Tenor..." style="width:100%; padding:8px; background:var(--bg-tertiary); border:none; border-radius:4px; color:var(--text-normal); margin-bottom:10px;">
                <div id="gifResults" style="flex:1; overflow-y:auto; display:grid; grid-template-columns:1fr 1fr; gap:5px;"></div>
            `;
        document.body.appendChild(picker); // Append to body or main-content related container

        // Re-position relative to input if possible, or just fixed
        const inputArea = document.querySelector(".input-area");
        if (inputArea) {
          const rect = inputArea.getBoundingClientRect();
          picker.style.bottom = (window.innerHeight - rect.top + 10) + "px";
          picker.style.right = "20px";
        }

        document.getElementById("gifSearchInput").addEventListener("input", (e) => {
          clearTimeout(window.searchTimeout);
          window.searchTimeout = setTimeout(() => searchTenor(e.target.value), 500);
        });

        // Initial load
        searchTenor("trending");
      }

      gifPickerOpen = !gifPickerOpen;
      picker.style.display = gifPickerOpen ? "flex" : "none";
    }

    async function searchTenor(query) {
      const resultsDiv = document.getElementById("gifResults");
      if (!resultsDiv) return;
      resultsDiv.innerHTML = '<div style="color:var(--text-muted); padding:10px;">Loading...</div>';

      const API_KEY = "LIVDSRZULELA";
      const url = `https://g.tenor.com/v1/search?q=${query}&key=${API_KEY}&limit=20`;

      try {
        const response = await fetch(url);
        const data = await response.json();
        resultsDiv.innerHTML = "";

        if (data.results) {
          data.results.forEach(gif => {
            const img = document.createElement("img");
            const media = gif.media[0];
            img.src = media.tinygif.url;
            img.style.cssText = "width:100%; height:auto; border-radius:4px; cursor:pointer;";
            img.onclick = () => {
              const text = `[gif]${media.gif.url}`;
              const activeKey = activeChatKey;
              if (!activeKey) return;

              if (activeKey.startsWith("server:")) {
                const [_, serverId, channelId] = activeKey.split(":");
                socket.emit("sendServerMsg", { serverId, channelId, text });
              } else {
                const [type, id] = activeKey.split(":");
                if (type === 'dm') {
                  encryptMessage(text, id).then(({ encrypted, data }) => {
                    socket.emit("sendDM", { target: id, text: encrypted ? '[encrypted]' : text, isEncrypted: encrypted, data });
                  });
                } else {
                  socket.emit("sendGroup", { groupId: id, text });
                }
              }

              toggleGifPicker(); // Close
            };
            resultsDiv.appendChild(img);
          });
        }
      } catch (e) {
        resultsDiv.innerHTML = '<div style="color:red; padding:10px;">Failed to load GIFs</div>';
      }
    }

    function startServerCall(serverId, channelId) {
      activeChatKey = `server:${serverId}:${channelId}`;
      socket.emit("join-call", { groupId: serverId, isGroup: true, channelId });
      renderList();
    }

    function leaveServer(serverId) {
      if (confirm("Are you sure you want to leave this server?")) {
        alert("Leave server not implemented in backend yet. Coming soon!");
      }
    }

  </script>
</body>

</html>